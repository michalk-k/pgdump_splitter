package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"pgdump_splitter/dbobjects"
	"regexp"
	"strconv"
)

// custom function for the Scanner.
// While default Scanner function strips EOL characters from the stream, this version maintains them untouched.
func preserveNewlines(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}
	for i := 0; i < len(data); i++ {
		if data[i] == '\n' {
			// Include the newline character in the token
			return i + 1, data[0 : i+1], nil
		}
	}
	// If at end of file and no newline found, return the entire data
	if atEOF {
		return len(data), data, nil
	}
	return 0, nil, nil
}

// Most outer processing function.
// It initializes a stream either from a file or pgdump, and processes it line by line.
func ProcessDump(args *Args) {

	err := os.RemoveAll(args.Dest)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	var scanner *bufio.Scanner

	// Open the file
	if args.File != "" {
		file, err := os.Open(args.File)
		if err != nil {
			fmt.Println("Error:", err)
			return
		}
		defer file.Close()
		scanner = bufio.NewScanner(file)
	} else {
		cmd := exec.Command(
			args.DCom,
			"-h"+args.Host,
			"-p"+strconv.Itoa(args.Port),
			"-U"+args.User,
			"--schema-only",
			args.DNme,
		)

		out, err := cmd.StdoutPipe()
		if err != nil {
			log.Fatal(err)
		}
		defer out.Close()

		err = cmd.Start()
		if err != nil {
			log.Fatal(err)
		}

		scanner = bufio.NewScanner(out)
	}

	rgx := regexp.MustCompile("^-- (Data for )?Name: (?P<Name>.*); Type: (?P<Type>.*); Schema: (?P<Schema>.*);")

	// Set the scanner to preserve original line endings
	scanner.Split(preserveNewlines)

	var curObj dbobjects.DbObject

	// Iterate over each line

	for scanner.Scan() {
		line := scanner.Text()

		matches := rgx.FindStringSubmatch(line)

		if len(matches) > 0 {

			if curObj.Content != "" {
				curObj.StoreObj()
			}

			// Iterate over each match
			result := make(map[string]string)
			for i, name := range rgx.SubexpNames() {
				if i != 0 && name != "" {
					result[name] = matches[i]
				}
			}
			curObj = dbobjects.DbObject{
				Rootpath: args.Dest,
				Name:     result["Name"],
				ObjType:  result["Type"],
				Schema:   result["Schema"],
				IsCustom: args.Mode == "custom",
			}

			continue
		}

		if curObj.ObjType != "" && curObj.ObjType != "TABLE DATA" {
			curObj.Content = curObj.Content + line
		}

	}

	if curObj.Content != "" {
		curObj.StoreObj()
	}

	// Check for any errors that may have occurred during scanning
	if err := scanner.Err(); err != nil {
		fmt.Println("Error:", err)
	}

}

// Structure handling program runtime configuration.
// Values are comming from command line arguments.
type Args struct {
	File string
	Mode string
	Host string
	Port int
	User string
	DNme string
	Dest string
	DCom string
}

func main() {

	var args Args
	var file string
	//	file = "/home/kozusznikm/gitrepo/pgdump_splitter_orig/test9.sql"
	args.File = *flag.String("f", file, "path to dump generated by pg_dump")
	args.DCom = *flag.String("c", "pg_dump", "The path to pg_dump command")
	args.Mode = *flag.String("m", "custom", "The mode of dumping db objects. origin - for file organization as present in the database dump. custom - reorganizes db objects storing related ones into single file")
	args.Host = *flag.String("h", "127.0.0.1", "Specifies the hostname of the machine on which the server is running. If the value begins with a slash, it is used as the directory for the Unix domain socket. The default is taken from the PGHOST environment variable, if set, else a Unix domain socket connection is attempted.")
	args.Port = *flag.Int("p", 50032, "Specifies the TCP port or local Unix domain socket file extension on which the server is listening for connections. Defaults to the PGPORT environment variable, if set, or a compiled-in default")
	args.User = *flag.String("u", "postgres", "User name to connect as.")
	args.DNme = *flag.String("d", "clients_and_terminals", "Specifies the name of the database pg_dump connects to")
	args.Dest = *flag.String("s", "/home/kozusznikm/gitrepo/pgdump_splitter_orig/structures/", "Location where structures will be dumped to")

	flag.Parse()

	if !(args.Mode == "" || args.Mode == "custom" || args.Mode == "origin") {
		fmt.Println("Invalid value passed to -m modifier")
		flag.PrintDefaults()
		return
	}
	if args.File == "" && args.Host == "" || args.Dest == "" {
		fmt.Println("Mandatory arguments are missing:")
		fmt.Println("The program must get either path to the dump file or database credentials to connect to. Also destination path is mandatory")
		fmt.Println("Available arguments:")
		flag.PrintDefaults()
		return
	}

	ProcessDump(&args)
	// Print the output
	fmt.Println("Finished")
}
