package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"pgdump_splitter/dbobjects"
	"regexp"
)

func pgdump() {
	cmd := exec.Command(
		"pg_dump",
		"-h127.0.0.1",
		"-p50032",
		"-Upostgres",
		"--file=dump.sql",
		"clients_and_terminals",
	)

	stdoutStderr, err := cmd.CombinedOutput()
	fmt.Printf("%s\n", stdoutStderr)

	if err != nil {
		log.Fatal(err)
	}
}

func preserveNewlines(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}
	for i := 0; i < len(data); i++ {
		if data[i] == '\n' {
			// Include the newline character in the token
			return i + 1, data[0 : i+1], nil
		}
	}
	// If at end of file and no newline found, return the entire data
	if atEOF {
		return len(data), data, nil
	}
	return 0, nil, nil
}

func ProcessDump(args Args) {

	err := os.RemoveAll(args.Dest)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	var scanner *bufio.Scanner

	// Open the file
	if args.File != "" {
		file, err := os.Open(args.File)
		if err != nil {
			fmt.Println("Error:", err)
			return
		}
		defer file.Close()
		scanner = bufio.NewScanner(file)
	} else {
		cmd := exec.Command(
			"pg_dump",
			"-h127.0.0.1",
			"-p50032",
			"-Upostgres",
			"--schema-only",
			"betsys",
		)
		out, err := cmd.StdoutPipe()
		if err != nil {
			log.Fatal(err)
		}
		defer out.Close()

		err = cmd.Start()
		if err != nil {
			log.Fatal(err)
		}

		scanner = bufio.NewScanner(out)
	}

	rgx := regexp.MustCompile("^-- (Data for )?Name: (?P<Name>.*); Type: (?P<Type>.*); Schema: (?P<Schema>.*);")

	// Set the scanner to preserve original line endings
	scanner.Split(preserveNewlines)

	var curObj dbobjects.DbObject

	// Iterate over each line

	for scanner.Scan() {
		line := scanner.Text()

		matches := rgx.FindStringSubmatch(line)

		if len(matches) > 0 {

			if curObj.Content != "" {
				curObj.StoreObj()
			}

			// Iterate over each match
			result := make(map[string]string)
			for i, name := range rgx.SubexpNames() {
				if i != 0 && name != "" {
					result[name] = matches[i]
				}
			}
			curObj = dbobjects.DbObject{
				Rootpath: args.Dest,
				Name:     result["Name"],
				ObjType:  result["Type"],
				Schema:   result["Schema"],
			}

			dbobjects.NormalizeDbObject(&curObj)

			continue
		}

		if curObj.ObjType != "TABLE DATA" {
			curObj.Content = curObj.Content + line
		}

	}

	// Check for any errors that may have occurred during scanning
	if err := scanner.Err(); err != nil {
		fmt.Println("Error:", err)
	}

}

type Args struct {
	File string
	Mode string
	Host string
	Port int
	User string
	DNme string
	Dest string
}

func main() {

	var args Args

	args.File = *flag.String("file", "", "path to dump generated by pg_dump")
	args.Mode = *flag.String("mode", "custom", "Dump objects as they are organized into dump, or reorganize, agregating related objects together. Available values: custom, origin")
	args.Host = *flag.String("host", "127.0.0.1", "address of the host, to be used for pg_dump")
	args.Port = *flag.Int("port", 50032, "address of the host, to be used for pg_dump")
	args.User = *flag.String("user", "postgres", "user name")
	args.DNme = *flag.String("dbname", "betsys", "name of database")
	args.Dest = *flag.String("destpath", "/home/kozusznikm/gitrepo/pgdump_splitter_orig/structures/", "Location where stuctures will be dumped to")

	flag.Parse()
	/*
		if args.File == "" || args.Dest == "" || args.Host == "" {
			fmt.Println("Mandatory arguments are missing:")
			fmt.Println("The program must get either path to the dump file or database credentials to connect to. Also destination path is mandatory")
			fmt.Println("Available arguments:")
			flag.PrintDefaults()
			return
		}
	*/
	ProcessDump(args)
	// Print the output
	fmt.Println("Finished")
}
