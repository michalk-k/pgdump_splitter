package main

import (
	"bufio"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"pgdump_splitter/dbobjects"
	"regexp"
	"strconv"
)

// custom function for the Scanner.
// While default Scanner function strips EOL characters from the stream, this version maintains them untouched.
func preserveNewlines(data []byte, atEOF bool) (advance int, token []byte, err error) {
	if atEOF && len(data) == 0 {
		return 0, nil, nil
	}
	for i := 0; i < len(data); i++ {
		if data[i] == '\n' {
			// Include the newline character in the token
			return i + 1, data[0 : i+1], nil
		}
	}
	// If at end of file and no newline found, return the entire data
	if atEOF {
		return len(data), data, nil
	}
	return 0, nil, nil
}

// Most outer processing function.
// It initializes a stream either from a file or pgdump, and processes it line by line.
func ProcessDump(args *Args) {

	err := os.RemoveAll(args.Dest)
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	var scanner *bufio.Scanner

	// Open the file
	if args.File != "" {
		file, err := os.Open(args.File)
		if err != nil {
			fmt.Println("Error:", err)
			return
		}
		defer file.Close()
		scanner = bufio.NewScanner(file)
	} else {
		cmd := exec.Command(
			"pg_dump",
			"-h"+args.Host,
			"-p"+strconv.Itoa(args.Port),
			"-U"+args.User,
			"--schema-only",
			args.DNme,
		)
		out, err := cmd.StdoutPipe()
		if err != nil {
			log.Fatal(err)
		}
		defer out.Close()

		err = cmd.Start()
		if err != nil {
			log.Fatal(err)
		}

		scanner = bufio.NewScanner(out)
	}

	rgx := regexp.MustCompile("^-- (Data for )?Name: (?P<Name>.*); Type: (?P<Type>.*); Schema: (?P<Schema>.*);")

	// Set the scanner to preserve original line endings
	scanner.Split(preserveNewlines)

	var curObj dbobjects.DbObject

	// Iterate over each line

	for scanner.Scan() {
		line := scanner.Text()

		matches := rgx.FindStringSubmatch(line)

		if len(matches) > 0 {

			if curObj.Content != "" {
				curObj.StoreObj()
			}

			// Iterate over each match
			result := make(map[string]string)
			for i, name := range rgx.SubexpNames() {
				if i != 0 && name != "" {
					result[name] = matches[i]
				}
			}
			curObj = dbobjects.DbObject{
				Rootpath: args.Dest,
				Name:     result["Name"],
				ObjType:  result["Type"],
				Schema:   result["Schema"],
				IsCustom: args.Mode == "custom",
			}

			dbobjects.NormalizeDbObject(&curObj)
			dbobjects.GenerateDestinationPath(&curObj)

			continue
		}

		if curObj.ObjType != "TABLE DATA" {
			curObj.Content = curObj.Content + line
		}

	}

	if curObj.Content != "" {
		curObj.StoreObj()
	}

	// Check for any errors that may have occurred during scanning
	if err := scanner.Err(); err != nil {
		fmt.Println("Error:", err)
	}

}

// Structure handling program runtime configuration.
// Values are comming from command line arguments.
type Args struct {
	File string
	Mode string
	Host string
	Port int
	User string
	DNme string
	Dest string
}

func main() {

	var args Args
	var file string
	// file = "/home/kozusznikm/gitrepo/pgdump_splitter_orig/test6.sql"
	args.File = *flag.String("f", file, "path to dump generated by pg_dump")
	args.Mode = *flag.String("m", "origin", "Dump objects as they are organized into dump, or reorganize, agregating related objects together. Available values: custom, origin")
	args.Host = *flag.String("h", "127.0.0.1", "address of the host, to be used for pg_dump")
	args.Port = *flag.Int("p", 50032, "address of the host, to be used for pg_dump")
	args.User = *flag.String("u", "postgres", "user name")
	args.DNme = *flag.String("d", "clients_and_terminals", "name of database")
	args.Dest = *flag.String("s", "/home/kozusznikm/gitrepo/pgdump_splitter_orig/structures/", "Location where stuctures will be dumped to")

	flag.Parse()

	if !(args.Mode == "" || args.Mode == "custom" || args.Mode == "origin") {
		fmt.Println("Invalid value passed to -m modifier")
		flag.PrintDefaults()
		return
	}
	if args.File == "" && args.Host == "" || args.Dest == "" {
		fmt.Println("Mandatory arguments are missing:")
		fmt.Println("The program must get either path to the dump file or database credentials to connect to. Also destination path is mandatory")
		fmt.Println("Available arguments:")
		flag.PrintDefaults()
		return
	}

	ProcessDump(&args)
	// Print the output
	fmt.Println("Finished")
}
